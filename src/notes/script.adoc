= Documentation as Code: Script

// .TODO
// - code friendly; built-in support for highlighted source blocks

// tag::title[]
Welcome everyone!

Today, I'm going to talk to you about how you can elevate your end-to-end content process, from writing to delivery, by treating documentation as code.
It starts by authoring your content in AsciiDoc and transforming it with Asciidoctor.
You'll then see how this system lets you to tie into existing social coding infrastructure for better collaboration and leverage build tools and pipelines for automated publishing.
What we're talking about here is reusing tools and process for writing that you're already using for your software development.

Before we get into that, I want to share my earliest memory of publishing and how it impacts my philosophy about writing content today.
// end::title[]

== Personal Story

// tag::print-shop-box[]
My first computer system was an Apple II with an ImageWriter.
Anyone remember that setup?
It was truly a magical machine of entertainment and possibility.
Best of all, it came bundled with The Print Shop!
// end::print-shop-box[]

// tag::print-shop-select[]
My siblings and I went nuts using it to make signs and banners and greeting cards.
There were a few years there when I thought Hallmark was going to go out of business because we were making so many birthday cards ourselves.

My go-to pick among the assortment of fonts, graphics, and borders was definitely the skull and crossbones.
I was told after a few times that, while cool, it wasn't necessarily the best choice for a birthday card.
Whatever.
I'd just use it then to make that most-important of adolescent items: a sign for my bedroom door that read "`Keep Out!`"
// end::print-shop-select[]

// tag::print-long-banner[]
Printing those signs was really my first experience publishing content.
Back then, we didn't all carry around screens in our pockets, so printing was how we'd share our creations with the world.
What an amazing sense of power it gave me.
I could write and have those words transformed into something material, tangible, and bigger than on screen.
And my words affected other people.
It was such a rush.
// end::print-long-banner[]

// tag::color-ribbon-cartridge[]
Now, on the practical side of things, printing was _not_ a speedy process.
The printer would screech and jerk in a flurry of perpetual commotion.
We're talking walk-away-and-come-back-in-an-hour kind of speed.
//DA: NOTE foreshadow automation here
//DA: Watching the printer's automation was fascinating, but would quickly put you into a trance. (video)
//DA: TODO typos were glaring (as you can see if you study banner image); mistakes were made; spell check twice, print once
Plus, the printer ribbons only lasted so long and required a special trip to the store to replace.
So my message--my content--had to be chosen wisely for optimum effect and impact, and to keep my parent's grievances about using up the ribbon to a minimum.
// end::color-ribbon-cartridge[]

// tag::print-banner[]
I also had to share this computer with my siblings.
We _all_ had something to say and each of us wanted _our_ message to be the one published for the world to see.
You know there's nothing more fierce than sibling competition.
So this was not only my first publishing experience, but also my first collaborative / argumentative one.
//DA: ...feeding into a world of automation
// end::print-banner[]

== Introduction

// tag::many-masters[]
Technical content today is not that far removed from my childhood print shop.
We must still choose our words wisely.
We must collaborate with others on the creation of content and in making sure it's available to the world.
And seeing our words printed is still just as thrilling.

To get there, we need a content workflow that ensures maximum reuse and facilitates strong collaboration while, at the same time, gives us the flexibility to transform the content however we want and publish it wherever it needs to go...automatically, and as quickly as possible.
The best way to fulfill all these demands...
// end::many-masters[]

// tag::separate[]
...is to separate the content from presentation--and even the infrastructure that makes the presentation possible.
That way, you can adapt your content to ever-changing stakeholder initiatives and technology landscapes.

But there's a careful balance you must achieve to avoid hindering creation, publication, or collaboration.
It's a balance I believe Asciidoctor strikes.
I'll explain why in this talk.
// end::separate[]

// tag::agenda[]
//We should consider three key capabilities when evaluating--and adopting--a content system.
//
//. Creation
//. Publication
//. Collaboration
//
//We'll evaluate Asciidoctor through the lens of these capabilities to investigate its strengths and discover how to get the most out of it.
We'll evaluate Asciidoctor through the lens of the following capabilities in order to investigate its strengths and discover how to get the most out of it.

// idea for visual: show magnifying glass overlay on list to indicate we're studying each capability
. Creation
. Publication
. Collaboration

Any good content system should score well in all three catagories.
// end::agenda[]

== Creation

// tag::creation[]
I'm going to start with the writers in the room.
Rest assured, I'm with you.

Like you, I believe content is king.
I also believe that a content system which doesn't consider the needs of the author first is not sustainable.
//alt: never going to work.
Writers need a system that allows them to do what they do best.
Writers write.
// end::creation[]

// tag::confined[]
But many content systems seem determined to make this essential task as difficult as possible.
They're cumbersome, complicated, and downright frustrating.
And that's tragic.
//alt: The struggle is real.
// end::confined[]

// DJA: Let's assume we're looking to create a document like this (show published output). What's out there that we can use write this?

// tag::docbook[]
Anyone recognize this?
Anyone like it?

This is DocBook.
DocBook is an XML schema that's highly structured and semantic with a keen focus on separating content and presentation.
So far, so good, right?
// end::docbook[]

// tag::docbook-critique-a[]
O_o
// end::docbook-critique-a[]

// tag::docbook-critique-b[]
As a writer, would you want to weave your content in and out of this web day-in and day-out?
Yeah, I didn't think so.

Content is shackled by this structure.
You have to enclose every chunk of content you write in a markup envelope.
But why?
It's so heavy.
And there's the added burden of having to remember all the tags and when to use them.

The ironic part is that the engineer didn't do herself much of a favor either.
XML tools--especially the ones used in the DocBook toolchain, such as XSLT--are a pain to work with.

Nobody wins here.
// end::docbook-critique-b[]

// tag::latex[]
Moving on, how about this?

Clearly, the engineer was having fun while the writer was away.
This is LaTeX (LAH-tekh).
LaTeX is a documentation preparation system (read as: low-level language) for high-quality typesetting widely used in academia.

The message here--if you can even interpret it--is:
"`I don't see the difference between content, typesetting, and presentation, so I'll just mash all these concerns together.`"
// end::latex[]

// tag::latex-critique-a[]
O_o
// end::latex-critique-a[]

// tag::latex-critique-b[]
Writers get lost in this syntax not only because it looks like a bird nest, but now there's a deluge of dialects that no mere mortal can possibly remember.
// end::latex-critique-b[]

// tag::got-pdf[]
The other major problem with LaTeX is that is was not designed with multi-channel web publishing in mind.
PDF anyone?
You're options are limited even before you've begun.

The point is that many content systems cater more--even exclusively--to the technologist rather than the writer.

That has _got_ to change.
That's where AsciiDoc comes in to save the day.
// end::got-pdf[]

// tag::asciidoc[]
How about this instead?
// end::asciidoc[]

// tag::asciidoc-critique[]
\o/

Ahh.
We created AsciiDoc as a writer-centric markup system.
And it shows.
The reaction many writers have when they switch to this syntax is, "`I can finally see my content!`"
That speaks volumes.
// end::asciidoc-critique[]

// concise * consistent * semantic
// tag::asciidoc-qualities[]
//LAR: Can we have a series of example slides as you go through this list of benefits?
//LAR: That would be more informative and engaging.
//LAR: I'm not wild about the highlighted list because it isn't "showing" what you're talking about, which is the point, right?
//LAR: Slides that show the AsciiDoc version and what is created (like the reference manual) would be great.
The first thing you'll notice is that the syntax is clear & concise.
//LAR: a slide here of the syntax that shows what you mean.
What you see is predominantly content.
It's readable in raw form, unlike other formats we've seen.

//LAR: Is this quote necessary?
//LAR: Maybe make it a slide and move it to the end of this section?
"#Perfection is achieved not when there's nothing more to add, but when there's nothing left to take away.#"
-- Antoine de Saint-ExubÃ©ry

Paragraphs are just paragraphs, no bullshit.
//LAR: give me an example slide.
The remaining tagging marks are based on familiar conventions, such as leading asterisks to itemize a list, asterisks around a phrase to emphasize it, and leading equal signs to designate a section title.
//LAR: another slide example.
Keywords that appear in the syntax are based on common terminology such as "`image`" and "`source`".

In general, the syntax is remarkably forgiving, which makes it less daunting for first timers.

If you dig deeper, you'll notice a consistency to the syntax.
Indeed, the language is based on repeatable patterns.
Extensions further build on these patterns, which we'll get into later.

Finally, the syntax is extremely semantic.
Each bit of content belongs to a node--a content block or phrase.
Nodes can be annotated with extra bits of information that states what the content is, how it might be presented, and other properties.
// end::asciidoc-qualities[]

// tag::ex-roles[]
The most versatile semantic information is the role.

Roles, and other such metadata, serve a very important purpose in the AsciiDoc syntax because they allow the writer to pass information to the publisher about the semantics of a node without having to worry how it gets formatted.
The role basically says "`this element has special significance, you deal with it.`"
This abtraction is central to achieving separation of content and presentation.
The writer can focus on the what, not the how.
// end::ex-roles[]

//DA: QUESTION should the point about line-oriented/left-align go right at beginning, before other characteristics?
// tag::left-aligned-lines[]
One reason the syntax is so simple and consistent is because it's both line-oriented and left-aligned.

Having a syntax that's aligned to the left margin helps keeps the writer rooted.
You needn't worry how many spaces are needed and content doesn't float out into the ether.
You rely on line-oriented fences to encompass the content instead.

The line-oriented arrangement takes advantage of the fact that source code organized in lines.
A lot can be inferred from a line break in the content.
Consecutive lines that start with an asterisk, for instance, are clearly items in a list.
We do the same thing when writing code.
Each statement gets its own line, so there's no need for a semicolon to separate statements.
// end::left-aligned-lines[]

// tag::ex-delimited-block[]
//LAR: give me an example slide with a result in it, please.
Delimited blocks are another example.
You add "`fences`" around a block of content.
AsciiDoc can then assume everything between those lines is content for that block.

//DA: TODO need a bit of a wrap-up/transition here
// end::ex-delimited-block[]

// tag::wysiwyg[]
So, what's absent here?

WYSIWYG.
// end::wysiwyg[]

// tag::ygwyg[]
You don't need it.
WYSIWYG places a barrier between you and your content and robs you of a lot of control.
Unfortunately, it's an all too familiar input component in a CMS.
I think of a CMS more as a content lobotomy system.
Instead of suiting your needs, it _seemingly_ solves your problem by making it impossible to do what you want to do.
I like to say, "`You Get What You Get.`"
// end::ygwyg[]

AsciiDoc, on the otherhand, is readable in raw form and there's no curtain between you and your content.
But that doesn't mean you can't make it look pretty.

// tag::atom[]
Using a text editor such as Atom with the appropriate add-ons, you can see the final product in a preview pane.
//alt: see how it's going to look in a preview pane
You can change, embellish, or restructure the entire document and see what the end result will be in real time.

//(If there's time: Discuss authoring in Atom with the AsciiDoc add-on to get helpful syntax highlighting.
//Also mention AsciidocFX and IntelliJ IDEA.)
// end::atom[]

// tag::ide-for-writers[]
I think tools such as Atom can go much further...maturing into a full blown IDE for writers.
Efforts are underway.
// end::ide-for-writers[]

// tag::creation-recommended-practices[]
AsciiDoc has many, _many_ built-in elements and options to organize and annotate your content.
You shouldn't expect to learn it all in one day.
But you also don't have to.

Most shops gravitate towards a subset of the markup.
Dialects, particularly using roles, naturally emerge that bring additional consistency and reinforce the impression of simplicity.
// See http://www.winglemeyer.org/technology/2016/09/08/semantic-asciidoc/
You can make templates for common document types to give writers an easy starting point.

// DA: TODO it feels like we should mention cross references here
Another way to simplify writing with AsciiDoc is to partition large documents.
For instance, you can split up the source of a book along chapter divisions.
You can also include common content or extract code samples so they don't clutter the view.
AsciiDoc supports all this through it's include mechanism.
You can even include parts of another document using fragments selected by line number or tag.
//DA: TODO recommend checking out the AsciiDoc Syntax Quick Reference and Awesome Asciidoctor.
// end::creation-recommended-practices[]

//DA: FIXME the topic of migration feels like it should be somewhere else
//DA: PSA about pandoc
// tag::migration[]
I won't get into migrating your existing content to AsciiDoc today, but be aware it's possible.
There are conversion tools, and many others have made the switch successfully.
See me afterward and I can give you some pointers.
// end::migration[]

// tag::dawn[]
So far, we've just talked about the source, the domain of the writer.
Now that you have your content encoded in AsciiDoc, what can you do with it?

The AsciiDoc syntax is so simple and elegant, it's easy to be deceived that it can only produce primitive output.
You couldn't be more mistaken.
The AsciiDoc content is just the raw material and its semantics are the seeds of the blossoms we'll produce.
This is where engineers get to work their magic.

Let's shed some light on how we can transform it and where we can publish it.
It's the dawn of endless possibilities, just like The Print Shop was for me as a child.
// end::dawn[]

== Publication

// tag::publication[]
The focus of this section is the AsciiDoc processor & publisher, Asciidoctor.
Engineers, wake up, this is for you.
// end::publication[]

// tag::asciidoc-vs-asciidoctor[]
AsciiDoc is the language. +
Asciidoctor is the processor.
// end::asciidoc-vs-asciidoctor[]

// tag::conversion[]
I want to start by mentioning that, out of the box, Asciidoctor can convert to HTML and DocBook, allowing you to preview and export the content, respectively.
This is just the default interpretation of the AsciiDoc source.
There's nothing stopping you from interpreting the source in a different way.
That's what separation of content and presentation affords you.
Every bit of output that gets generated can be customized in one way or another.
You should look at the AsciiDoc source as a source of record, not a textual representation of the output.
// end::conversion[]

// tag::ex-extensions[]
I'll cite a few examples to get you thinking about what is possible.

* tabs
* background image for slide
* import PDF page
* slide notes
// end::ex-extensions[]

// tag::ast[]
What we're talking about here is transformation.
Transformation is the key to being able to publish to multiple channels in a variety of formats.

When Asciidoctor reads the file, it builds an AST, or abstract syntax tree.
That tree is passed to a converter, which than transforms it into the target format, such as HTML.

One way to extend Asciidoctor is to write a custom converter, or build on one that already exists.
The only limit to what output formats you can produce is what you're willing/able to create.

But even before the tree is sent to the converter, you have a chance to manipulate it or mine it for information.
In fact, you don't even need to output anything.
You can just use the AST to query the document for information in a contextual way (unlike grep, which is crude and blind to context)

You can even go one step further and tap into the parser itself.
Asciidoctor provides an extension API to allow you to add additional elements to the syntax, such as a custom block or macro.
This stuff literally makes me giddy.
// end::ast[]

// tag::aggregate[]
As you can see, you have a lot of control over how the AsciiDoc is interpretted.
Be careful not to fall into the trap of thinking that one input document produces one output document.
You could take one input document that represents a book and produce multiple pages of HTML.
You can also go the other way.
You could use the processor, or a toolchain that wraps it, that takes input from several sources and weaves them together.
Where we see this technique used is in API documentation tools like Spring REST Docs and swagger2markup, which generate AsciiDoc to document the API methods, then combine it with content written by the author and produces a document (or documents) to be published.
Part generated, part scribed.
The toolchain plays the role of orchestrator, weaving together disparate content sources.
// end::aggregate[]

// tag::endless-possibilities[]
There truly are endless possibilities for your content once in this format and managed by this toolchain.
This transformation capability also keeps you from being tied down.
Just as you can generate formats for publishing, you can generate to another source format, even AsciiDoc.
If you store the source in a version control system, which we'll talk more about in the next section, the publication tool can even tap into the document history and inject content such as an audit log or make different versions of the document available.
This is another powerful way to keep your content DRY and free from doing tasks for information that can be implied.
//You could extend the abstraction even further and avoid coupling the path of the source file with the output path.
//Instead, give each document a business ID so you can move files around and still produce the same output structure.
// end::endless-possibilities[]

// tag::push-to-publish[]
Last but not least, publication should be fully managed by an automated build.
It doesn't end with Asciidoctor.
The build should not only handle converting the content and publishing it to the various channels, but should describe and manage the infrastructure as well.
Treat your docs just like you would any other application.
It should be possible to "`push to publish`" and the computer takes over from there.
These automated builds also aid with collaboration, which we'll get into next.
// end::push-to-publish[]

// tag::publish-everywhere[]
// TODO
// end::publish-everywhere[]

// tag::publication-recommended-practices[]
// TODO
// end::publication-recommended-practices[]

== Collaboration

// tag::collaboration[]
What you'll find is that AsciiDoc lends itself very well to collaboration because much of the tools we need are already in place.
While there's a bit more assembly required up front, what you'll likely find is that it blows any proprietary, closed system out of the water.

This section addresses both the writers and the engineers, and anyone else involved in the content effort.
No doubt what makes AsciiDoc ripe for collaboration above all else is that it is version-control friendly.
AsciiDoc doesn't have "`source control support,`" rather it just lends itself to being source controlled.
No binary blobs, just plain text.
And version-control systems love plain text.
You get history, source diffs, rich diffs, branching, merging, etc., all which can be managed with interfaces like GitHub and GitLab.
// end::collaboration[]

// tag::redhat-endorsement[]
And this is a real force for contribution, as the JBoss BxMS and OpenShit teams have both observed:

> The OpenShift team reported that after the migration from DocBook to AsciiDoc, the rate of both internal and external contributions skyrocketed--from several a year to several a week. ...
>
> ...{sp}Mere days after our migration, we started seeing incoming Merge Requests, where there were none before.
> Preliminary results hint that this is an observable trend.
> -- JBoss BxMS Engineering Team
// end::redhat-endorsement[]

// tag::edit-on-github[]
Nothing drives that more, invites participation more, than the "`Edit on GitHub`" link.

But the team does need to understand how the "`Edit on GitHub`" process actually works and know how to manage the git workflow.
I do strongly recommend investing in git training for your team.
Knowing how to use git correctly will save time and toes.
// end::edit-on-github[]

// tag::asciidoc-github-support[]
It's impossible to overstate the significance of GitHub (and, increasingly, GitLab).
These interfaces have proven to be incredibly approachable and encourage contribution.
You can benefit from that phenomenon by moving your documentation there.
// end::asciidoc-github-support[]

// tag::docs-as-code[]
All this leads to a strong-held belief of ours.
Docs = Code
Why is that interesting?
Well, we have a long history in this industry of collaborating on code.
If we view docs as just another form of code, we can benefit from all of its processes, pratices, techniques, and tools.
// end::docs-as-code[]

// tag::code-review[]
One of the first tools that comes to mind is code review.
Countless CMS tools have tried to manufacture a content review workflow.
Well, we have one right here, (built on an accepted industry practice), supported by incredible code review tools like Gerrit, GitHub, GitLab, and so forth.

This system is also advantageous to the manager.
It makes it easy for managers to moniter the workflow, such as to determine what changed or what work was done, simply by looking at the git history or activity charts on GitHub and GitLab.
// end::code-review[]

// FIXME missing slides for the following part of the script
////
Given that AsciiDoc is just plain text, like developers, writers can use their own tools in their own writing environment.
No need for special, proprietary, foreign, costly tools.
In fact, you really should avoid imposing tool/editor choices.
You can work in isolation, then just push to publish.
Why is this important?
"`Happy people collaborate well`" (or are more inclined to).
How do you coordinate efforts?
Use an issue tracker to manage bugs, improvements, and content initiatives.
You can then see content progress as it moves across the issue board.
<figure:issue board>
Mention the issue when submitting the pull request that resolves it.
Just like code.
<figure:git history>
////

// tag::collaboration-recommended-practices[]
Although AsciiDoc is naturally friendly to version-control systems, there are ways to organize the content that let you get even more out of it.
For instance, I highly recommend writing with a sentence-per-line style.
By doing so, you isolate changes to the line of content that they affect, much like changing a line of code.
If you use fixed-column hard-wrapping, the change at the beginning of a paragraph can have a cascading effect, possibly interfering with unrelated lines that someone else is modifying.
In general, you want to look for ways that allow you to work in different parts of a file without causing conflicts.
Isolate your changes.

Another way to avoid such conflicts is to use well-factored, modular content.
You want a consistent, intuitive, and discoverable structure.
Consider using the topic-based authoring method so the content can be stored separately from the files that aggregate it.
As mentioned before, import non-content such as code snippets from the original source file (possibly even in a separate repository) so that it can be managed independently and doesn't fall out of date.
// TODO mention git lfs

It's best to have a style guide: for syntax; for structure; for patterns; for voice.
Automate the human process.
This reduces the amount of thought, avoids errors, and drastically cuts down on expensive micro-migrations to fix mistakes.
Again, the document templates mentioned earlier benefit collaboration as well.

Validation tools are also important because they help ensure quality and consistency.
You can tap into the Asciidoctor process to perform validations in addition to the ones that come out of the box.

Don't fall into the trap of putting all your content in a single repository.
Instead, organize your repositories by software product or logical product group.
We can refer to this repository as a "`content container.`" (a contrast to a "`library layout`" where there's one directory per book)
You can then assume that all the content in a single repository is versioned together.
If different documents have different versioning schemes, or move at different rates, that's an indicator you should move them to separate repositories.
Also avoid creating monolithic documents.
In particular, beware of the Russian Doll Effect (contributing guide inside developer guide inside of README).
It's easy to create a script that brings them all back together.

The reason this partitioning is important is because it enables you to leverage branches properly.
Have a branch for each major release line.
Different major (and maybe even minor) versions of the document should be stored in separate branches.
Don't use different directories to store the versions, as I've seen some teams do.
You lose a lot of capabilities of the version control system by not using branches because the commands for those systems don't understand how to compare documents that way.
It's also much harder to search for content.

Take a look at AsciiBinder for an example of a build system that builds out versions of the documentation from the branches.
Regardless of what structure you choose, anyone should be able to build the output through a simple interface, without having to remember complex commands.
That's why it's important to have an automated build, which obviously benefits publication as discussed earlier.
// end::collaboration-recommended-practices[]

TODO need a wrap-up/transition

//(See https://www.youtube.com/watch?v=JvRd7MmAxPw&list=PLZAeFn6dfHpnN8fXXHwPtPY33aLGGhYLJ&index=20)

== Conclusion

// tag::recap[]
In this talk, we evaluated AsciiDoc through the lens of three capabilities: creation; publication; and collaboration.

In any content system, the writer must be the focus, first and foremost.
Otherwise, the system is destined for failure.
It's vital to protect the sanctity of writing.
But the engineer must be empowered as well to transform that content.
Content that's locked away cannot serve its function, cannot reach its users across channels.

Like the technology that it documents, technical writing benefits from many eyes and minds.
Anything inherently complex does.
So the system must be friendly to collaboration.
It's the key to getting contributions as well.

As we've seen, the Asciidoctor toolchain, from the AsciiDoc language to the Asciidoctor processor, extensions, converters, and tools, strikes this balance.
These capabilities happen to be the three pillars of the Asciidoctor project, so we expect the story to only get better.
// tag::recap[]

// tag::fin[]
//Write in AsciiDoc, publish everywhere!

Thank you!
// end::fin[]
